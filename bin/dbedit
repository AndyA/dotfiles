#!/usr/bin/env perl

use strict;
use warnings;
use File::Basename;
use File::Path;
use Memoize;
use Getopt::Long;
use File::Temp qw( tempfile );

$| = 1;

my @path = map glob, qw( /etc/dbsave.cfg ~/.dbsave ./dbsave.cfg );
my $me = basename( $0 );

my %config = (
    DBHOST     => 'localhost',
    MYSQL      => 'mysql',
    MYSQLDUMP  => 'mysqldump',
    MYSQLEXTRA => '',
    DIR        => '.',
    INCLUDE    => [],
    EXCLUDE    => [],
    EDITOR     => $ENV{EDITOR} || 'vim',
);

my @dumpopts = qw(
  --add-drop-table
  --extended-insert=FALSE
  --complete-insert=TRUE
  --routines
);

memoize( 'enum_databases' );
memoize( 'enum_tables' );

our $CONFIG;

for my $cfg ( grep -e, @path ) {
    local $CONFIG = undef;
    require $cfg;
    # Handle legacy configs that assign to $CONFIG
    add_config( %{$CONFIG} ) if 'HASH' eq ref $CONFIG;
}

my $list_only = 0;
my $help_only = 0;

GetOptions(
    'u|username=s' => \$config{DBUSER},
    'p|password=s' => \$config{DBPASS},
    'host=s'       => \$config{DBHOST},
    'e|editor=s'   => \$config{EDITOR},
    'L'            => \$list_only,
    'h|help'       => \$help_only,
) or syntax();

if ( $help_only ) {
    syntax();
}
elsif ( $list_only ) {
    list_matching( @ARGV );
}
else {
    my ( $dh, $df ) = tempfile( UNLINK => 1, SUFFIX => '.sql' );

    dump_to( $dh, @ARGV );
    close $dh;
    edit_file( $df ) && do {
        load_from( $df );
        print "Database updated\n";
    };
}
exit;

sub dump_to {
    my ( $fh, @spec ) = @_;
    my $work = expand_wildcards( @spec );

    die "No tables match @spec\n" unless keys %$work;

    for my $db ( sort keys %$work ) {
        dump_database( $fh, $db, sort keys %{ $work->{$db} } );
    }
}

sub list_matching {
    my $work = expand_wildcards( @_ );
    for my $db ( sort keys %$work ) {
        for my $table ( sort keys %{ $work->{$db} } ) {
            print "$db.$table\n";
        }
    }
}

sub dump_database {
    my ( $oh, $db, @tab ) = @_;

    if ( @tab ) {
        my $cmd = mysql_cmd( 'MYSQLDUMP', @dumpopts, $db, @tab );
        open my $in, "$cmd|" or die "Can't exec $cmd ($!)\n";
        print $oh "CREATE DATABASE /*!32312 IF NOT EXISTS*/ `$db`;\n";
        print $oh "USE `$db`;\n\n";
        while ( <$in> ) {
            print $oh $_;
        }
        close $in or die "Can't exec $cmd ($!)\n";
    }
}

sub edit_file {
    my $file      = shift;
    my $ts_before = -M $file;
    return !system( cfg( 'EDITOR' ), $file ) && -M $file < $ts_before;
}

sub load_from {
    my $file = shift;
    my $cmd  = "cat $file | " . mysql_cmd( 'MYSQL' );
    system( $cmd) == 0
      or die "$cmd failed ($?)\n";
}

sub cfg { $config{ shift() } }

sub switch {
    my ( $flag, $key ) = @_;
    if ( defined( my $val = cfg( $key ) ) ) {
        return "$flag$val";
    }
    return;
}

sub mysql_cmd {
    my $key = shift;
    return join ' ', grep defined,
      cfg( $key ),
      switch ( '-u ',         'DBUSER' ),
      switch ( '--host=',     'DBHOST' ),
      switch ( '--password=', 'DBPASS' ),
      cfg( 'MYSQLEXTRA' ), @_;
}

sub catch_command {
    my $cmd = shift;
    my @db  = ();
    open my $ch, "$cmd|" or die "Can't shell $cmd ($!)\n";
    while ( <$ch> ) {
        chomp;
        push @db, $_;
    }
    close $ch or die "Can't shell $cmd ($!)\n";
    shift @db;
    return @db;
}

sub enum_databases {
    return catch_command(
        "echo SHOW DATABASES | " . mysql_cmd( 'MYSQL' ) );
}

sub enum_tables {
    return catch_command(
        "echo SHOW TABLES | " . mysql_cmd( 'MYSQL', @_ ) );
}

sub expand_wildcards {
    my $got = {};
    for my $dt ( @_ ) {
        my ( $db, $table ) = split( /\./, $dt );
        $table = '*' unless defined $table;
        for ( $db, $table ) {
            $_ = quotemeta( $_ );
            s/\\\*/.*/g;
            s/\\\?/./g;
        }
        for my $d ( grep /^$db$/, enum_databases() ) {
            for my $t ( grep /^$table$/, enum_tables( $d ) ) {
                $got->{$d}->{$t}++;
            }
        }
    }
    return $got;
}

sub add_config {
    die "Config must be a list of key => value pairs"
      if @_ % 2;
    %config = ( %config, @_ );
}

sub syntax {
    print <<EOS;
Syntax: dbedit <options> database[.table] ...

Options:
    -u --username Set the MySQL username
    -p --password Set the MySQL password
       --host     Set the MySQL host
    -e --editor   Set the editor to use
    -L            List matching tables
EOS
    exit;
}
