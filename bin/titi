#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use Time::ParseDate;
use YAML qw( DumpFile LoadFile );

use constant CONFIG => glob( '~/.titi' );

my $wrk = -f CONFIG ? LoadFile( CONFIG ) : {};

my %opt = (
  verbose => 0,
  help    => 0,
  nowrite => 0,
);

my %verb = (
  list => {
    action => sub {
      print "Working on...\n";
    },
    desc => sub {
      return undef, "List all known tickets.";
    },
    opts => sub {
      return;
    },
  },
  commit => {
    action => sub {
      my $ticket = $wrk->{current} || die "No current ticket\n";
      local $ENV{TITI_EDITOR} = $ENV{EDITOR} || 'vim';
      local $ENV{EDITOR} = 'titiedit';
      unless ( system 'svn', 'commit', @_ ) {
        my $info = svn_info();
        checkpoint( $ticket, $info->{Revision} );
      }
    },
    desc => sub {
      return '[<ticket #>]',
       "Do an svn commit with prefilled commit message.",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  get => {
    action => sub {
      my $ticket  = get_real_ticket( @_ );
      my $elapsed = elapsed( $ticket );
      print "Refs #", $ticket, " (spent ", fmt_hours( $elapsed ), ")\n";
      checkpoint( $ticket );
    },
    desc => sub {
      return '[<ticket #>]',
       "Get elapsed time on ticket since last get.",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  unget => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return '[<ticket #>]',
       "Forget most recent get on a ticket.",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  stop => {
    action => sub {
      no_args( @_ );
      if ( my $cur = $wrk->{current} ) {
        stop( $cur );
      }
      else {
        mention( "you weren't working on anything" );
      }
    },
    desc => sub {
      return undef, "Stop all work.";
    },
    opts => sub {
      return;
    },
  },
  start => {
    action => sub {
      my $ticket = get_ticket( @_ );
      my $cur = $wrk->{current} || 0;
      if ( $ticket == $cur && state( $cur ) eq 'working' ) {
        mention( "you are already working on $ticket" );
      }
      else {
        stop( $cur ) if $cur;
        mark( working => $ticket );
        mention( "working on $ticket" );
        $wrk->{current} = $ticket;
      }
    },
    desc => sub {
      return '[<ticket #>]',
       "Start work on a ticket. ",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
);

my %optspec = (
  'v|verbose' => \$opt{verbose},
  'h|help'    => \$opt{help},
  'N|nowrite' => \$opt{nowrite},
);

my $act = shift @ARGV or bail( 'No verb specified' );
my $vb  = $verb{$act} or bail( "Unknown action: $act" );

%optspec = ( %optspec, $vb->{opts}->() )
 if $vb->{opts};

Getopt::Long::Configure( "bundling" );
GetOptions( %optspec ) or bail();

$vb->{action}->( @ARGV );

DumpFile( CONFIG, $wrk ) unless $opt{nowrite};

sub bail {
  my $msg = join '', @_;
  die "$msg\n";
}

sub fmt_time {
  my $tm = shift || $^T;
  return strftime '%Y/%m/%d %H:%M:%S', localtime $tm;
}

sub fmt_hours {
  sprintf '%.2f', shift() / 3600;
}

sub mention {
  my $msg = join '', @_;
  print fmt_time(), " $msg\n";
}

sub no_args {
  die "No args allowed\n" if @_;
}

sub state {
  my $ticket = shift;
  return 'missing' unless @{ $wrk->{ticket}{$ticket} || [] };
  return $wrk->{ticket}{$ticket}[-1][0] || 'missing';
}

# Get all the active time slots since the last 'cp' mark
sub elapsed {
  my $ticket = shift;
  my @marks
   = reverse @{ $wrk->{ticket}{$ticket} || [ [ 'working', $^T ] ] };
  unshift @marks, [ 'stopped', $^T ]
   unless $marks[0][0] eq 'stopped';
  my @slots = ();
  my $lt;
  for my $mark ( @marks ) {
    my ( $state, $time ) = @$mark;
    if ( $state eq 'stopped' ) {
      $lt = $time;
    }
    elsif ( $state eq 'working' ) {
      die "*** No last time - shouldn't happen"
       unless $lt;
      unshift @slots, [ $time, $lt ];
    }
    elsif ( $state eq 'cp' ) {
      last;
    }
    else {
      die "*** Bad state: $state - shouldn't happen";
    }
  }

  return @slots if wantarray;

  my $total = 0;
  for my $slot ( @slots ) {
    my ( $from, $to ) = @$slot;
    $total += $to - $from - 1;
  }

  return $total;
}

sub mark {
  my ( $state, $ticket, @extra ) = @_;
  push @{ $wrk->{ticket}{$ticket} }, [ $state => $^T, @extra ];
}

sub checkpoint {
  my ( $ticket, @extra ) = @_;
  my $state = state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mark( cp      => $ticket, @extra );
    mark( working => $ticket );
  }
  elsif ( $state eq 'stopped' ) {
    mark( cp => $ticket );
  }
}

sub stop {
  my $ticket = shift;
  my $state  = state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mention( "stopped work on $ticket" );
  }
  else {
    mention( "you weren't working on $ticket ($state)" );
  }
}

sub get_ticket {
  my @args = @_;
  my $ticket 
   = shift @args
   || $wrk->{current}
   || die "No ticket specified and no active ticket\n";
  $ticket =~ s/ ^    #//;
  die "Ticket number \"$ticket\" is not numeric\n"
   unless $ticket =~ /^\d+$/;
  die "Too many args - expected a single ticket number\n"
   if @args;
  return $ticket;
}

sub get_real_ticket {
  my $ticket = get_ticket( @_ );
  die "No ticket $ticket\n" unless $wrk->{ticket}{$ticket};
  return $ticket;
}

sub tidy {
  my $s = shift;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub with_cmd {
  my ( @cmd ) = @_;
  my $code = pop @cmd;
  my $cmd = join ' ', @cmd;
  open my $sh, '-|', @cmd or die "Can't $cmd ($!)\n";
  while ( <$sh> ) { chomp; $code->() }
  close $sh or warn "Can't $cmd ($!) -- at exit\n";
  return $?;
}

sub with_svn {
  my @cmd  = @_;
  my $code = pop @cmd;
  my $info = {};
  with_cmd(
    svn => @cmd,
    sub {
      return if /^\s*$/;
      my ( $k, $v ) = $code->();
      $k =~ s/\s+//g;
      $info->{$k} = $v;
    }
  );
  return $info;
}

sub svn_info {
  with_svn( info => @_, sub { map tidy( $_ ), split /:/, $_, 2 } );
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

