#!/usr/bin/env perl
#
# TODO
#
# Implement reports.
#
# Make it possible to
#  * backdate work/break
#  * swap between current/previous ticket
#  * purge old data

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use Text::Wrap qw( wrap );
use Time::ParseDate;
use YAML qw( DumpFile LoadFile );

use constant CONFIG  => glob( '~/.titi' );
use constant STDHELP => "Type 'titi help' for a "
 . "list of supported subcommands and their options.";

my $wrk = -f CONFIG ? LoadFile( CONFIG ) : {};

my %opt = (
  verbose => 0,
  nowrite => 0,
);

my %verb = (
  status => {
    action => sub {
      my $ticket = get_real_ticket( @_ );
      my $worked = total( $ticket );
      my $commit = elapsed( $ticket );
      my $status = get_state( $ticket );
      print table(
        [ 'Ticket:', $ticket ],
        [ 'Total work:',             fmt_human( $worked, 2 ) ],
        [ 'Work since last commit:', fmt_human( $commit, 2 ) ],
        [ 'State:',                  $status ]
      );
    },
    desc => sub {
      return '[<ticket-id>]', "Get current status.";
    },
    opts => sub {
      return;
    },
  },
  help => {
    action => sub { help( @_ ) },
    desc   => sub {
      return undef, "Get help.";
    },
    opts => sub {
      return;
    },
  },
  report => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return "<report-id> ...", "Generate reports.";
    },
    opts => sub {
      return;
    },
  },
  commit => {
    action => sub {
      my $ticket = $wrk->{current} || bail( "No current ticket" );
      local $ENV{TITI_EDITOR} = $ENV{EDITOR} || 'vim';
      local $ENV{EDITOR} = 'titiedit';
      my @cmd = ( 'svn', 'commit', @_ );
      my $cmd = join ' ', @cmd;
      my @rev = ();
      open my $ch, '-|', @cmd or die "$cmd failed\n";
      while ( <$ch> ) {
        print;
        push @rev, $1 if /^Committed\srevision\s(\d+)/;
      }
      close $ch or die "$cmd failed\n";
      if ( @rev ) {
        checkpoint( $ticket, @rev );
        mention( "$ticket committed" );
      }
    },
    desc => sub {
      return undef,
       "Do an svn commit with prefilled commit message.",
       "There must be a currently selected ticket. "
       . "Any additional arguments are passed through to svn commit.",
       "If the commit is successful the current ticket will be "
       . "checkpointed - so that successive commits record the "
       . "time since the previous commit.",
       [
        '-f',
        '--foo',
        'this is the description of the foo command '
         . '(which is a really useful command, you know). Do you like it?'
       ],
       [ '',   '--bar', 'something else' ],
       [ '-v', '',      'verbose. say lots.' ];
    },
    opts => sub {
      return;
    },
  },
  get => {
    action => sub {
      my $ticket  = get_real_ticket( @_ );
      my $elapsed = elapsed( $ticket );
      print "Refs #", $ticket, " (spent ", fmt_hours( $elapsed ), ")\n";
      checkpoint( $ticket );
    },
    desc => sub {
      return '[<ticket-id>]',
       "Get elapsed time on ticket since last get.",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  unget => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return '[<ticket-id>]',
       "Forget most recent get on a ticket.",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  break => {
    action => sub {
      no_args( @_ );
      if ( my $cur = $wrk->{current} ) {
        stop( $cur );
      }
      else {
        mention( "you weren't working on anything" );
      }
    },
    desc => sub {
      return undef, "Stop all work.";
    },
    opts => sub {
      return;
    },
  },
  work => {
    action => sub {
      my $ticket = get_ticket( @_ );
      my $cur = $wrk->{current} || 0;
      if ( $ticket eq $cur && get_state( $cur ) eq 'working' ) {
        mention( "you are already working on $ticket" );
      }
      else {
        stop( $cur ) if $cur;
        mark( working => $ticket );
        mention( "working on $ticket" );
        $wrk->{current} = $ticket;
      }
    },
    desc => sub {
      return '[<ticket-id>]',
       "Start work on a ticket. ",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
);

my %optspec = (
  'v|verbose' => \$opt{verbose},
  'N|nowrite' => \$opt{nowrite},
);

my @opthelp = (
  [ '-v', '--verbose', 'Be verbose.' ],
  [
    '-N',
    '--nowrite',
    "Do not update ~/.titi. "
     . "Use to run commands without altering the saved state."
  ]
);

my $act = shift @ARGV
 or bail( "No subcommand specified. ", STDHELP );
my $vb = $verb{ abbrev( \%verb, $act ) };

%optspec = ( %optspec, $vb->{opts}->() )
 if $vb->{opts};

Getopt::Long::Configure( "bundling" );
GetOptions( %optspec ) or bail( STDHELP );

$vb->{action}->( @ARGV );

DumpFile( CONFIG, $wrk ) unless $opt{nowrite};

sub bail {
  $Text::Wrap::columns = 68;
  die wrap( '', '', join '', @_ ), "\n";
}

sub table {
  my @row   = @_;
  my @width = ();
  for my $r ( @row ) {
    for my $c ( 0 .. $#$r ) {
      my $len = length $r->[$c];
      $width[$c] = $len if ( $width[$c] || 0 ) < $len;
    }
  }
  $width[-1] = '';
  my $fmt = join ' ', map "%-${_}s", @width;
  my @table = ();
  for my $r ( @row ) {
    push @table, sprintf $fmt, @$r;
  }
  return join "\n", @table, '';
}

sub abbrev {
  my ( $hash, $got ) = @_;
  my @hit = grep /^\Q$got/, keys %$hash;
  bail( "No subcommand matches $got\n", STDHELP ) unless @hit;
  bail( "$got is ambiguous: ", ( join ', ', sort @hit ), "\n", STDHELP )
   if @hit > 1;
  return $hit[0];
}

sub fmt_time {
  my $tm = shift || $^T;
  return strftime '%Y/%m/%d %H:%M:%S', localtime $tm;
}

sub fmt_human {
  sprintf '%s (%s)', fmt_duration( @_ ), fmt_hours( @_ );
}

sub fmt_hours {
  sprintf '%.2f', shift() / 3600;
}

sub fmt_duration {
  my ( $dur, $prec ) = @_;
  return 'none' if $dur == 0;
  my @units = (
    [ 60,      'second', 'seconds' ],
    [ 60,      'minute', 'minutes' ],
    [ 24,      'hour',   'hours' ],
    [ 7,       'day',    'days' ],
    [ 1000000, 'week',   'weeks' ],
  );
  my @parts = ();
  for my $u ( @units ) {
    my ( $sz, $si, $pl ) = @$u;
    unshift @parts, [ $dur % $sz, $si, $pl, $sz / 2 ];
    $dur = int( $dur / $sz ) or last;
  }
  if ( defined $prec ) {
    while ( @parts > $prec ) {
      my $drop = pop @parts;
      my ( $sz, $si, $pl, $half ) = @$drop;
      $parts[-1][0]++ if @parts && $sz >= $half;
    }
  }
  return join ', ',
   map { join ' ', $_->[0], $_->[0] == 1 ? $_->[1] : $_->[2] } @parts;
}

sub mention {
  my $msg = join '', @_;
  print fmt_time(), " $msg\n";
}

sub no_args {
  bail( "No args allowed" ) if @_;
}

sub get_state {
  my $ticket = shift;
  return 'missing' unless @{ $wrk->{ticket}{$ticket} || [] };
  return $wrk->{ticket}{$ticket}[-1][0] || 'missing';
}

sub slots_to_seconds {
  my @slots = @_;
  my $total = 0;
  for my $slot ( @slots ) {
    my ( $from, $to ) = @$slot;
    $total += $to - $from - 1;
  }

  return $total;
}

sub marks_for {
  my $ticket = shift;
  my @marks = @{ $wrk->{ticket}{$ticket} || [ [ 'working', $^T ] ] };
  push @marks, [ 'stopped', $^T ]
   unless $marks[-1][0] eq 'stopped';
  return @marks;
}

# Get all the active time slots since the last 'commit' mark
sub elapsed {
  my ( $ticket, $nostop ) = @_;
  my @marks = reverse marks_for( $ticket );
  my @slots = ();
  my $lt;
  for my $mark ( @marks ) {
    my ( $state, $time ) = @$mark;
    if ( $state eq 'stopped' ) {
      $lt = $time;
    }
    elsif ( $state eq 'working' ) {
      die "*** No last time - shouldn't happen"
       unless $lt;
      unshift @slots, [ $time, $lt ];
    }
    elsif ( $state eq 'commit' ) {
      last unless $nostop;
    }
    else {
      die "*** Bad state: $state - shouldn't happen";
    }
  }

  return @slots if wantarray;
  return slots_to_seconds( @slots );
}

sub total { elapsed( shift(), 'nostop' ) }

sub mark {
  my ( $state, $ticket, @extra ) = @_;
  push @{ $wrk->{ticket}{$ticket} }, [ $state => $^T, @extra ];
}

sub checkpoint {
  my ( $ticket, @extra ) = @_;
  my $state = get_state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mark( commit  => $ticket, @extra );
    mark( working => $ticket );
  }
  else {
    mark( commit => $ticket, @extra );
  }
}

sub stop {
  my $ticket = shift;
  my $state  = get_state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mention( "stopped work on $ticket" );
  }
  else {
    mention( "you weren't working on $ticket ($state)" );
  }
}

sub get_ticket {
  my @args = @_;
  my $ticket 
   = shift @args
   || $wrk->{current}
   || bail( "No ticket specified and no active ticket" );
  $ticket =~ s/^#//;
  bail( "Too many args - expected a single ticket number" )
   if @args;
  return $ticket;
}

sub get_real_ticket {
  my $ticket = get_ticket( @_ );
  bail( "No ticket $ticket" ) unless $wrk->{ticket}{$ticket};
  return $ticket;
}

sub fmt_opt {
  my ( $tbl, $spec ) = @_;
  local $Text::Wrap::columns = 50;
  my ( $short, $long, $desc ) = @$spec;
  $short .= ',' if $short and $long;
  my @lines = split /\n/, wrap( '', '', $desc );
  push @$tbl, [ ' ', $short, $long, ':', shift @lines ];
  push @$tbl, map { [ '', '', '', '', $_ ] } @lines;
}

sub help {
  my @args   = @_;
  my $indent = '  ';
  if ( @args ) {
    my $v = shift @args;
    bail( "usage: titi help <subcommand>" )
     if @args;
    my $vv = abbrev( \%verb, $v );
    my ( $args, $desc, @paras ) = $verb{$vv}{desc}->();
    print "$vv: $desc\n";
    print "usage: titi ", join( ' ', grep defined, $vv, $args ), "\n";
    my @text   = ();
    my @table  = ();
    my @global = ();

    for my $p ( @paras ) {
      if ( 'ARRAY' eq ref $p ) {
        fmt_opt( \@table, $p );
      }
      else {
        local $Text::Wrap::columns = 68;
        push @text, wrap( $indent, $indent, $p );
      }
    }

    fmt_opt( \@global, $_ ) for @opthelp;

    print "\n", join( "\n\n", @text ), "\n" if @text;
    print "\nValid options:\n", table( @table ) if @table;
    print "\nGlobal options:\n", table( @global ), "\n";
  }
  else {
    my @table = ();

    for my $v ( sort keys %verb ) {
      my ( $args, $desc ) = $verb{$v}{desc}->();
      push @table, [ $indent, $v, $args || '', $desc ];
    }

    print "usage: titi <subcommand> [options] [args]\n\n",
     "Subcommands:\n",
     table( @table ),
     "\nType titi 'help <subcommand>' for help ",
     "on a specific command.\n";
  }
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

