#!/usr/bin/env perl
#
# TODO
#
# Implement reports.
#
# Make it possible to
#  * swap between current/previous ticket
#  * purge old data
#  * edit ticket timeline

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use Text::Wrap qw( wrap );
use Time::Local;
use Time::ParseDate;
use YAML qw( DumpFile LoadFile );

use constant CONFIG  => glob( '~/.titi' );
use constant COLUMNS => 72;
use constant INDENT  => 2;

use constant STDHELP => "Type 'titi help' for a "
 . "list of supported subcommands and their options.";

my $wrk = -f CONFIG ? LoadFile( CONFIG ) : {};

my %opt = (
  quiet   => 0,
  nowrite => 0,
);

my %report = (
  log => {
    action => sub {
      my @flat = @_;
      my @report = ( [ 'Time', 'Ticket', 'Event' ], '=' );
      for my $elt ( @flat ) {
        my ( undef, $ticket, $state, $time, @extra ) = @$elt;
        push @report, [ fmt_time( $time ), $ticket, $state, @extra ];
      }
      print table( @report );
    },
    desc => sub {
    },
  },
);

my %verb = (
  status => {
    action => sub {
      my $ticket = get_real_ticket( @_ );
      my $worked = total( $ticket );
      my $commit = elapsed( $ticket );
      my $status = get_state( $ticket );
      print table(
        [ 'Ticket:', $ticket ],
        [ 'Total work:',             fmt_human( $worked, 2 ) ],
        [ 'Work since last commit:', fmt_human( $commit, 2 ) ],
        [ 'State:',                  $status ]
      );
    },
    desc => sub {
      return '[ticket id]', "Get a summary of current status.";
    },
    opts => sub {
      return;
    },
  },
  help => {
    action => sub { help( @_ ) },
    desc   => sub {
      return '[subcommand]', "Get help.";
    },
    opts => sub {
      return;
    },
  },
  report => {
    action => sub {
      my @args    = @_;
      my @tickets = ();

      for my $arg ( @args ) {
        if ( $arg =~ /^[@](.+)/ ) { push @{ $opt{report} }, $1 }
        else                      { push @tickets, split /,/, $arg }
      }

      unless ( @tickets ) {
        bail( 'No tickets named and no current ticket.' )
         unless $wrk->{current};
        push @tickets, $wrk->{current};
      }

      @tickets = sort keys %{ $wrk->{ticket} } if $opt{all};

      my @reports = uniq( map { split /,/ } @{ $opt{report} } );
      @reports = sort keys %report unless @reports;
      need( 'report', 'reports', \%report,       @reports );
      need( 'ticket', 'tickets', $wrk->{ticket}, @tickets );

      my @filters = ();
      if ( $opt{today} ) {
        my $midnight = midnight();
        push @filters, sub { $_->[1] >= $midnight };
      }

      push @filters, sub { 1 }
       unless @filters;
      my @flat = flatten_ticket( pred_and( @filters ), @tickets );
      for my $rep ( @reports ) {
        print "Report: $rep\n";
        $report{$rep}{action}( @flat );
      }
    },
    desc => sub {
      my @avail = sort keys %report;
      return "[ticket id ...]", "Generate reports.",
         "By default all known reports are generated; use -R to "
       . "limit which reports are shown. If no tickets are nominated "
       . "reports will be generated for the current ticket, if any.",
       "The following "
       . noun( scalar @avail, 'report is', 'reports are' )
       . " available: "
       . and_list( @avail ),
       [ '-A', '--all', 'Report on all tickets.' ],
       [
        '-R',
        '--report <report id>',
        'Select a report. May be used more than once.'
       ],
       [ '-T', '--today', 'Limit report to today.' ];
    },
    opts => sub {
      %opt = (
        %opt,
        all    => 0,
        report => [],
        today  => 0
      );
      return 'A|all' => \$opt{all},
       'R|report=s@' => \$opt{report},
       'T|today'     => \$opt{today};
    },
  },
  commit => {
    action => sub {
      my $ticket = $wrk->{current} || bail( "No current ticket" );
      local $ENV{TITI_EDITOR} = editor();
      local $ENV{EDITOR}      = 'titiedit';
      my @cmd = ( 'svn', 'commit', @_ );
      my $cmd = join ' ', @cmd;
      my @rev = ();
      open my $ch, '-|', @cmd or die "$cmd failed\n";
      while ( <$ch> ) {
        print;
        push @rev, $1 if /^Committed\srevision\s(\d+)/;
      }
      close $ch or die "$cmd failed\n";
      if ( @rev ) {
        checkpoint( $ticket, @rev );
        mention( "$ticket committed" );
      }
    },
    passthru => 1,
    desc     => sub {
      return '[svn commit options]',
       "Do an svn commit with prefilled commit message.",
       "There must be a currently selected ticket. "
       . "Any additional arguments are passed through to svn commit.",
       "If the commit is successful the current ticket will be "
       . "checkpointed so that successive commits record the "
       . "time since the previous commit or get.";
    },
    opts => sub {
      return;
    },
  },
  get => {
    action => sub {
      my $ticket  = get_real_ticket( @_ );
      my $elapsed = elapsed( $ticket );
      print "Refs #", $ticket, " (spent ", fmt_hours( $elapsed ), ")\n";
      checkpoint( $ticket );
    },
    desc => sub {
      return '[ticket id]',
       "Get elapsed time on a ticket.",
       "Gets the time since the last checkpoint on the ticket "
       . "and adds a new checkpoint. Each get (or "
       . "commit) gets the time worked on that ticket since the "
       . "last get (or commit).",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  edit => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return '[ticket id]',
       "Edit the timeline for a ticket using " . editor() . ".",
       "Set the EDITOR environment variable to use an editor other than "
       . editor() . ".",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  break => {
    action => sub {
      no_args( @_ );
      if ( my $cur = $wrk->{current} ) {
        stop( $cur );
      }
      else {
        mention( "you weren't working on anything" );
      }
    },
    desc => sub {
      return undef, "Stop all work.",
       "Used to indicate that you are not working on any ticket.",
       "The last ticket you worked on is remembered so that "
       . "you can resume work by typing 'titi work'.";
    },
    opts => sub {
      return;
    },
  },
  work => {
    action => sub {
      my $ticket = get_ticket( @_ );
      my $cur = $wrk->{current} || 0;
      if ( $ticket eq $cur && get_state( $cur ) eq 'working' ) {
        mention( "you are already working on $ticket" );
      }
      else {
        stop( $cur ) if $cur;
        mark( working => $ticket );
        mention( "working on $ticket" );
        $wrk->{current} = $ticket;
      }
    },
    desc => sub {
      return '[ticket id]',
       "Start work on a ticket. ",
       "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
);

my %optspec = (
  'q|quiet'   => \$opt{quiet},
  'N|nowrite' => \$opt{nowrite},
);

my @opthelp = (
  [ '-h', '--help',  'Get help.' ],
  [ '-q', '--quiet', 'Say as little as possible.' ],
  [
    '-N',
    '--nowrite',
    "Do not update '" 
     . CONFIG . "'. "
     . "Use to run commands without altering the saved state."
  ]
);

@ARGV = 'help' if grep /^(?:-h|--help)$/, @ARGV;
my $act = shift @ARGV
 or bail( "No subcommand specified. ", STDHELP );
my $vb = $verb{ abbrev( \%verb, $act ) };

%optspec = ( %optspec, $vb->{opts}->() )
 if $vb->{opts};

unless ( $vb->{passthru} ) {
  Getopt::Long::Configure( "bundling" );
  GetOptions( %optspec ) or bail( STDHELP );
}

$vb->{action}->( @ARGV );

DumpFile( CONFIG, $wrk ) unless $opt{nowrite};

sub bail {
  $Text::Wrap::columns = COLUMNS;
  die wrap( '', '', join '', @_ ), "\n";
}

sub editor { $ENV{EDITOR} || 'vim' }

sub table {
  my @row   = @_;
  my @width = ();
  my %opts  = ();
  for my $r ( @row ) {
    next unless ref $r;
    if ( 'HASH' eq ref $r ) {
      %opts = ( %opts, %$r );
    }
    else {
      for my $c ( 0 .. $#$r ) {
        my $len = length $r->[$c];
        $width[$c] = $len if ( $width[$c] || 0 ) < $len;
      }
    }
  }

  my $mkfmt = sub { join ' ', map "%-${_}s", @_ };
  my $tw = $opts{columns} || length sprintf $mkfmt->( @width ),
   ( '' ) x @width;

  $width[-1] = '';
  my $fmt   = $mkfmt->( @width );
  my $pad   = length sprintf $fmt, ( '' ) x @width;
  my @table = ();
  for my $r ( @row ) {
    next if 'HASH' eq ref $r;
    if ( 'ARRAY' eq ref $r ) {
      my @row = ( @$r, ( '' ) x ( @width - @$r ) );
      if ( $opts{columns} && @$r == @width ) {
        my $cols = $opts{columns} - $pad;
        $cols = 20 if $cols < 20;
        local $Text::Wrap::columns = $cols;
        my @para = split /\n/, wrap( '', '', pop @row );
        push @table, sprintf $fmt, @row, shift @para;
        push @table, map { sprintf $fmt, ( '' ) x @row, $_ } @para;
      }
      else {
        push @table, sprintf $fmt, @row;
      }
    }
    else {
      push @table, $r =~ /^\W$/ ? $r x $tw : $r;
    }
  }
  return join "\n", @table, '';
}

sub abbrev {
  my ( $hash, $got ) = @_;
  my @hit = grep /^\Q$got/, keys %$hash;
  bail( "No subcommand matches $got\n", STDHELP ) unless @hit;
  bail( "$got is ambiguous: ", ( join ', ', sort @hit ), "\n", STDHELP )
   if @hit > 1;
  return $hit[0];
}

sub fmt_time {
  my $tm = shift || $^T;
  return strftime '%Y/%m/%d %H:%M:%S', localtime $tm;
}

sub fmt_human {
  sprintf '%s (%s)', fmt_duration( @_ ), fmt_hours( @_ );
}

sub fmt_hours {
  sprintf '%.2f', shift() / 3600;
}

sub fmt_duration {
  my ( $dur, $prec ) = @_;
  return 'none' if $dur == 0;
  my @units = (
    [ 60,      'second', 'seconds' ],
    [ 60,      'minute', 'minutes' ],
    [ 24,      'hour',   'hours' ],
    [ 7,       'day',    'days' ],
    [ 1000000, 'week',   'weeks' ],
  );
  my @parts = ();
  for my $u ( @units ) {
    my ( $sz, $si, $pl ) = @$u;
    unshift @parts, [ $dur % $sz, $si, $pl, $sz / 2 ];
    $dur = int( $dur / $sz ) or last;
  }
  if ( defined $prec ) {
    while ( @parts > $prec ) {
      my $drop = pop @parts;
      my ( $sz, $si, $pl, $half ) = @$drop;
      $parts[-1][0]++ if @parts && $sz >= $half;
    }
  }
  return join ', ',
   map { join ' ', $_->[0], $_->[0] == 1 ? $_->[1] : $_->[2] } @parts;
}

sub mention {
  return if $opt{quiet};
  my $msg = join '', @_;
  print fmt_time(), " $msg\n";
}

sub no_args {
  bail( "No args allowed" ) if @_;
}

sub get_state {
  my $ticket = shift;
  return 'missing' unless @{ $wrk->{ticket}{$ticket} || [] };
  return $wrk->{ticket}{$ticket}[-1][0] || 'missing';
}

sub slots_to_seconds {
  my @slots = @_;
  my $total = 0;
  for my $slot ( @slots ) {
    my ( $from, $to ) = @$slot;
    $total += $to - $from - 1;
  }

  return $total;
}

sub marks_for {
  my $ticket = shift;
  my @marks = @{ $wrk->{ticket}{$ticket} || [ [ 'working', $^T ] ] };
  push @marks, [ 'stopped', $^T ]
   unless $marks[-1][0] eq 'stopped';
  return @marks;
}

# Get all the active time slots since the last 'commit' mark
sub elapsed {
  my ( $ticket, $nostop ) = @_;
  my @marks = reverse marks_for( $ticket );
  my @slots = ();
  my $lt;
  for my $mark ( @marks ) {
    my ( $state, $time ) = @$mark;
    if ( $state eq 'stopped' ) {
      $lt = $time;
    }
    elsif ( $state eq 'working' ) {
      die "*** No last time - shouldn't happen"
       unless $lt;
      unshift @slots, [ $time, $lt ];
    }
    elsif ( $state eq 'commit' ) {
      last unless $nostop;
    }
    else {
      die "*** Bad state: $state - shouldn't happen";
    }
  }

  return @slots if wantarray;
  return slots_to_seconds( @slots );
}

sub total { elapsed( shift(), 'nostop' ) }

sub mark {
  my ( $state, $ticket, @extra ) = @_;
  push @{ $wrk->{ticket}{$ticket} }, [ $state => $^T, @extra ];
}

sub checkpoint {
  my ( $ticket, @extra ) = @_;
  my $state = get_state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mark( commit  => $ticket, @extra );
    mark( working => $ticket );
  }
  else {
    mark( commit => $ticket, @extra );
  }
}

sub stop {
  my $ticket = shift;
  my $state  = get_state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mention( "stopped work on $ticket" );
  }
  else {
    mention( "you weren't working on $ticket ($state)" );
  }
}

sub get_ticket {
  my @args = @_;
  my $ticket 
   = shift @args
   || $wrk->{current}
   || bail( "No ticket specified and no active ticket" );
  $ticket =~ s/^#//;
  bail( "Too many args - expected a single ticket number" )
   if @args;
  return $ticket;
}

sub get_real_ticket {
  my $ticket = get_ticket( @_ );
  bail( "No ticket $ticket" ) unless $wrk->{ticket}{$ticket};
  return $ticket;
}

sub fmt_opt {
  my ( $tbl, $spec ) = @_;
  local $Text::Wrap::columns = 50;
  my ( $short, $long, $desc ) = @$spec;
  $short .= ',' if $short and $long;
  push @$tbl, [ ' ' x ( INDENT - 1 ), $short, $long, ':', $desc ];
}

sub globals {
  my @global = ();
  fmt_opt( \@global, $_ ) for @opthelp;
  return "Global options:\n", table( { columns => COLUMNS }, @global );
}

sub conj_list {
  my ( $conj, @list ) = @_;
  return unless @list;
  my $last = pop @list;
  return $last unless @list;
  return join " $conj ", join( ', ', @list ), $last;
}

sub and_list { conj_list( and => @_ ) }
sub or_list  { conj_list( or  => @_ ) }

sub noun {
  my ( $n, $si, $pl ) = @_;
  $n == 1 ? $si : $pl;
}

sub passthru {
  my @pt = @_ ? @_ : sort grep { $verb{$_}{passthru} } keys %verb;
  return unless @pt;
  $Text::Wrap::columns = COLUMNS - INDENT;
  my $pad = ' ' x INDENT;
  return wrap(
    $pad, $pad,
    join(
      '', "The ",
      and_list( @pt ),
      ' ',
      noun(
        scalar @pt,
        'subcommand passes its',
        'subcommands pass their'
      ),
      ' arguments directly to the command that ',
      noun( scalar @pt, 'it invokes. It does', 'they invoke. They do' ),
      ' not accept the standard titi options.'
    )
   ),
   "\n";
}

sub help {
  my @args = @_;
  my $pad  = ' ' x INDENT;
  if ( @args ) {
    my $v = shift @args;
    bail( "usage: titi help [subcommand]" )
     if @args;
    my $vv = abbrev( \%verb, $v );
    my ( $args, @paras ) = $verb{$vv}{desc}->();
    print "usage: titi ", join( ' ', grep defined, $vv, $args ), "\n";
    my @text  = ();
    my @table = ();

    for my $p ( @paras ) {
      if ( 'ARRAY' eq ref $p ) {
        fmt_opt( \@table, $p );
      }
      else {
        local $Text::Wrap::columns = COLUMNS - INDENT;
        push @text, wrap( $pad, $pad, $p );
      }
    }

    print "\n", join( "\n\n", @text ), "\n" if @text;
    print "\nValid options:\n", table( { columns => COLUMNS }, @table )
     if @table;
    print "\n";
    print $verb{$vv}{passthru} ? passthru( $vv ) : globals();
    print "\n";
  }
  else {
    my @table = ();

    for my $v ( sort keys %verb ) {
      my ( $args, $desc ) = $verb{$v}{desc}->();
      push @table, [ ' ' x ( INDENT - 1 ), $v, $args || '', $desc ];
    }

    print "usage: titi <subcommand> [options] [args]\n\n",
     "Subcommands:\n",
     table( { columns => COLUMNS }, @table ), "\n", globals(),
     "\nExceptions:\n", passthru(),
     "\nType titi 'help <subcommand>' for help ",
     "on a specific command.\n";
  }
}

sub flatten_ticket {
  my ( $filter, @tickets ) = @_;
  my @flat = ();
  my $idx  = 0;
  for my $ticket ( @tickets ) {
    for ( @{ $wrk->{ticket}{$ticket} || [] } ) {
      # Add an index so we can ensure the sort is stable
      push @flat, [ $idx++, $ticket, @$_ ] if $filter->();
    }
  }
  return sort { $a->[3] <=> $b->[3] || $a->[0] <=> $b->[0] } @flat;
}

sub midnight {
  my $time = shift || $^T;
  my ( undef, undef, undef, $mday, $mon, $year ) = localtime( $time );
  return timelocal( 0, 0, 0, $mday, $mon, $year );
}

sub uniq {
  my %seen = ();
  grep { !$seen{$_}++ } @_;
}

sub missing {
  my ( $hash, @keys ) = @_;
  grep { !exists $hash->{$_} } @keys;
}

sub need {
  my ( $si, $pl, $hash, @keys ) = @_;
  my @missing = missing( $hash, @keys );
  return unless @missing;
  bail( 'No ', noun( scalar @missing, $si, $pl ),
    ' with id ', or_list( @missing ), '.' );
}

sub pred_and {
  my @pred = @_;
  return sub { return }
   if @pred == 0;
  return $pred[0]
   if @pred == 1;
  return sub {
    for my $p ( @pred ) {
      return 1 if $p->();
    }
    return;
  };
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

