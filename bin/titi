#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use Time::ParseDate;
use YAML qw( DumpFile LoadFile );

use constant CONFIG => glob( '~/.titi' );

my $wrk = -f CONFIG ? LoadFile( CONFIG ) : {};

my %opt = (
  verbose => 0,
  help    => 0,
  nowrite => 0,
);

my %verb = (
  status => {
    action => sub {
      my $ticket = get_real_ticket( @_ );
      my $worked = total( $ticket );
      my $commit = elapsed( $ticket );
      my $status = get_state( $ticket );
      print table(
        [ 'Ticket:', $ticket ],
        [ 'Total work:',             fmt_human( $worked, 2 ) ],
        [ 'Work since last commit:', fmt_human( $commit, 2 ) ],
        [ 'State:',                  $status ]
      );
    },
    desc => sub {
      return undef, "Get current status.";
    },
    opts => sub {
      return;
    },
  },
  today => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return undef, "What have you done today?";
    },
    opts => sub {
      return;
    },
  },
  list => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return undef, "List all known tickets.";
    },
    opts => sub {
      return;
    },
  },
  commit => {
    action => sub {
      my $ticket = $wrk->{current} || die "No current ticket\n";
      local $ENV{TITI_EDITOR} = $ENV{EDITOR} || 'vim';
      local $ENV{EDITOR} = 'titiedit';
      my @cmd = ( 'svn', 'commit', @_ );
      my $cmd = join ' ', @cmd;
      my @rev = ();
      open my $ch, '-|', @cmd or die "$cmd failed\n";
      while ( <$ch> ) {
        print;
        push @rev, $1 if /^Committed\srevision\s(\d+)/;
      }
      close $ch or die "$cmd failed\n";
      if ( @rev ) {
        checkpoint( $ticket, @rev );
        mention( "$ticket committed" );
      }
    },
    desc => sub {
      return undef,
        "Do an svn commit with prefilled commit message.",
        "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  get => {
    action => sub {
      my $ticket  = get_real_ticket( @_ );
      my $elapsed = elapsed( $ticket );
      print "Refs #", $ticket, " (spent ", fmt_hours( $elapsed ), ")\n";
      checkpoint( $ticket );
    },
    desc => sub {
      return '[<ticket #>]',
        "Get elapsed time on ticket since last get.",
        "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  unget => {
    action => sub {
      die "Not implemented\n";
    },
    desc => sub {
      return '[<ticket #>]',
        "Forget most recent get on a ticket.",
        "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
  break => {
    action => sub {
      no_args( @_ );
      if ( my $cur = $wrk->{current} ) {
        stop( $cur );
      }
      else {
        mention( "you weren't working on anything" );
      }
    },
    desc => sub {
      return undef, "Stop all work.";
    },
    opts => sub {
      return;
    },
  },
  work => {
    action => sub {
      my $ticket = get_ticket( @_ );
      my $cur = $wrk->{current} || 0;
      if ( $ticket eq $cur && get_state( $cur ) eq 'working' ) {
        mention( "you are already working on $ticket" );
      }
      else {
        stop( $cur ) if $cur;
        mark( working => $ticket );
        mention( "working on $ticket" );
        $wrk->{current} = $ticket;
      }
    },
    desc => sub {
      return '[<ticket #>]',
        "Start work on a ticket. ",
        "Defaults to the last ticket you worked on.";
    },
    opts => sub {
      return;
    },
  },
);

my %optspec = (
  'v|verbose' => \$opt{verbose},
  'h|help'    => \$opt{help},
  'N|nowrite' => \$opt{nowrite},
);

my $act = shift @ARGV or bail( 'No verb specified' );
my $vb = $verb{ abbrev( \%verb, $act ) };

%optspec = ( %optspec, $vb->{opts}->() )
  if $vb->{opts};

Getopt::Long::Configure( "bundling" );
GetOptions( %optspec ) or bail();

$vb->{action}->( @ARGV );

DumpFile( CONFIG, $wrk ) unless $opt{nowrite};

sub bail {
  my $msg = join '', @_;
  die "$msg\n";
}

sub table {
  my @row   = @_;
  my @width = ();
  for my $r ( @row ) {
    for my $c ( 0 .. $#$r ) {
      my $len = length $r->[$c];
      $width[$c] = $len if ( $width[$c] || 0 ) < $len;
    }
  }
  $width[-1] = '';
  my $fmt = join ' ', map "%-${_}s", @width;
  my @table = ();
  for my $r ( @row ) {
    push @table, sprintf $fmt, @$r;
  }
  return join "\n", @table, '';
}

sub abbrev {
  my ( $hash, $got ) = @_;
  my @hit = grep /^\Q$got/, keys %$hash;
  die "No action matches $got\n" unless @hit;
  die "$got is ambiguous: ", ( join ', ', sort @hit ), "\n" if @hit > 1;
  return $hit[0];
}

sub fmt_time {
  my $tm = shift || $^T;
  return strftime '%Y/%m/%d %H:%M:%S', localtime $tm;
}

sub fmt_human {
  sprintf '%s (%s)', fmt_duration( @_ ), fmt_hours( @_ );
}

sub fmt_hours {
  sprintf '%.2f', shift() / 3600;
}

sub fmt_duration {
  my ( $dur, $prec ) = @_;
  return 'none' if $dur == 0;
  my @units = (
    [ 60,      'second', 'seconds' ],
    [ 60,      'minute', 'minutes' ],
    [ 24,      'hour',   'hours' ],
    [ 7,       'day',    'days' ],
    [ 1000000, 'week',   'weeks' ],
  );
  my @parts = ();
  for my $u ( @units ) {
    my ( $sz, $si, $pl ) = @$u;
    unshift @parts, [ $dur % $sz, $si, $pl, $sz / 2 ];
    $dur = int( $dur / $sz ) or last;
  }
  if ( defined $prec ) {
    while ( @parts > $prec ) {
      my $drop = pop @parts;
      my ( $sz, $si, $pl, $half ) = @$drop;
      $parts[-1][0]++ if @parts && $sz >= $half;
    }
  }
  return join ', ',
    map { join ' ', $_->[0], $_->[0] == 1 ? $_->[1] : $_->[2] } @parts;
}

sub mention {
  my $msg = join '', @_;
  print fmt_time(), " $msg\n";
}

sub no_args {
  die "No args allowed\n" if @_;
}

sub get_state {
  my $ticket = shift;
  return 'missing' unless @{ $wrk->{ticket}{$ticket} || [] };
  return $wrk->{ticket}{$ticket}[-1][0] || 'missing';
}

sub slots_to_seconds {
  my @slots = @_;
  my $total = 0;
  for my $slot ( @slots ) {
    my ( $from, $to ) = @$slot;
    $total += $to - $from - 1;
  }

  return $total;
}

sub marks_for {
  my $ticket = shift;
  my @marks = @{ $wrk->{ticket}{$ticket} || [ [ 'working', $^T ] ] };
  push @marks, [ 'stopped', $^T ]
    unless $marks[-1][0] eq 'stopped';
  return @marks;
}

# Get all the active time slots since the last 'commit' mark
sub elapsed {
  my ( $ticket, $nostop ) = @_;
  my @marks = reverse marks_for( $ticket );
  my @slots = ();
  my $lt;
  for my $mark ( @marks ) {
    my ( $state, $time ) = @$mark;
    if ( $state eq 'stopped' ) {
      $lt = $time;
    }
    elsif ( $state eq 'working' ) {
      die "*** No last time - shouldn't happen"
        unless $lt;
      unshift @slots, [ $time, $lt ];
    }
    elsif ( $state eq 'commit' ) {
      last unless $nostop;
    }
    else {
      die "*** Bad state: $state - shouldn't happen";
    }
  }

  return @slots if wantarray;
  return slots_to_seconds( @slots );
}

sub total { elapsed( shift(), 'nostop' ) }

sub mark {
  my ( $state, $ticket, @extra ) = @_;
  push @{ $wrk->{ticket}{$ticket} }, [ $state => $^T, @extra ];
}

sub checkpoint {
  my ( $ticket, @extra ) = @_;
  my $state = get_state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mark( commit  => $ticket, @extra );
    mark( working => $ticket );
  }
  else {
    mark( commit => $ticket, @extra );
  }
}

sub stop {
  my $ticket = shift;
  my $state  = get_state( $ticket );
  if ( $state eq 'working' ) {
    mark( stopped => $ticket );
    mention( "stopped work on $ticket" );
  }
  else {
    mention( "you weren't working on $ticket ($state)" );
  }
}

sub get_ticket {
  my @args = @_;
  my $ticket 
    = shift @args
    || $wrk->{current}
    || die "No ticket specified and no active ticket\n";
  $ticket =~ s/^#//;
  die "Too many args - expected a single ticket number\n"
    if @args;
  return $ticket;
}

sub get_real_ticket {
  my $ticket = get_ticket( @_ );
  die "No ticket $ticket\n" unless $wrk->{ticket}{$ticket};
  return $ticket;
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

