#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use File::Basename qw( basename dirname );
use File::Path qw( mkpath );
use File::Spec;
use Getopt::Long;

our $CtlDir  = find_up( '.svnmeta' );
our $BaseDir = dirname( $CtlDir );
die "Can't find .svnmeta control directory\n" unless defined $CtlDir;
chdir $BaseDir or die "Can't chdir to $BaseDir: $!\n";
our $ConfigFile = File::Spec->catfile( $CtlDir, 'config' );

our %Opt = (
  quiet => 0,
  all   => 0,
);

GetOptions(
  'Q|quiet' => \$Opt{quiet},
  'A|all'   => \$Opt{all},
) or die;

my $verb = shift;
defined $verb or die "usage: svnmeta <verb> <options>\n";

die $ConfigFile, " doesn't exist, can't continue\n"
 unless -e $ConfigFile;
our $Config = read_config( $ConfigFile );

if ( $verb =~ /^up(?:date)?$/ ) {
  update();
}
elsif ( $verb =~ /^st(?:atus)?$/ ) {
  status();
}
else {
  die "Unknown action: $verb\n";
}

sub mention(@) {
  print join( '', @_ ), "\n" unless $Opt{quiet};
}

sub svn(@) {
  my @arg = @_;
  my $cb = sub { };
  $cb = pop @arg if @arg && 'CODE' eq ref $arg[-1];
  open my $h, '-|', 'svn', @arg or die "Can't run svn: $!\n";
  while ( <$h> ) {
    chomp;
    mention( $_ );
    $cb->( $_ );
  }
  close $h or die "svn failed: $?\n";
}

sub is_svn($) {
  my $d = shift;
  return -d $d && -d File::Spec->catdir( $d, '.svn' );
}

sub update {
  for my $root ( get_roots() ) {
    if ( is_svn $root ) {
      mention "Update $root";
      svn update => $root;
    }
    elsif ( -d $root ) {
      warn "$root exists but is not an svn repository\n";
    }
    else {
      mention "Checkout $root";
      mkpath( dirname( $root ) );
      svn checkout => repo_url( $root ), $root;
    }
  }
}

sub status {
  for my $root ( get_roots() ) {
    if ( is_svn $root ) {
      svn status => $root;
    }
  }
}

sub get_roots {
  my @types = $Opt{all} ? keys %{ $Config->{t} } : 'TRACK';
  return for_types( @types );
}

sub for_types {
  my @types = @_;
  return sort map { @{ $Config->{t}{$_} || [] } } @types;
}

sub repo_url {
  my $name = shift;
  my $base = $Config->{v}{repo};
  die "No repo defined in ", $ConfigFile unless defined $base;
  $base =~ s{/$}{};
  return join '/', $base, $name;
}

sub read_config {
  my $name    = shift;
  my %vars    = ();
  my %by_type = ();
  open my $fh, '<', $name or die "Can't read $name: $!\n";
  while ( <$fh> ) {
    chomp;
    next if /^\s*$/;
    next if /^#/;
    my $line = $_;
    if ( $line =~ /^(\w+)\s*=\s*(.*)/ ) {
      $vars{$1} = $2;
    }
    elsif ( $line =~ /^(HOLD|TRACK)\s+(.+)$/ ) {
      $by_type{$1}{$2}++;
    }
    else {
      die "Bad syntax in $name";
    }
  }

  my $config = { v => \%vars, t => {} };
  for my $t ( keys %by_type ) {
    $config->{t}{$t} = [ uniq( sort keys %{ $by_type{$t} } ) ];
  }
  return $config;
}

sub uniq {
  my %seen = ();
  return grep { !$seen{$_}++ } @_;
}

sub find_up {
  my $name = File::Spec->rel2abs( shift );
  return $name if -e $name;
  my ( $dir, $base ) = ( dirname( $name ), basename( $name ) );
  return if $dir eq File::Spec->rootdir;
  return find_up( File::Spec->catdir( dirname( $dir ), $base ) );
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

