#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use Path::Class qw( file );
use LWP::UserAgent;
use HTML::Parser;

use constant SIEVETEST =>
 'http://www.fastmail.fm/docs/sieve/sievetest.php';

GetOptions() or die "Stopping\n";

my ( $sieve, @email ) = @ARGV;
die "Please name a sieve (source) script to test\n"
 unless defined $sieve;

my $sieve_src = file( $sieve )->slurp;
for my $email ( @email ) {
  my $email_src = file( $email )->slurp;
  print sieve_test( $sieve_src, $email_src ), "\n";
}

sub sieve_test {
  my ( $sieve, $mail ) = @_;
  my $ua   = LWP::UserAgent->new;
  my $resp = $ua->post(
    SIEVETEST,
    {
      btn         => 'Run Test',
      mode        => 'test',
      sieveemail  => $mail,
      sievescript => $sieve,
    }
  );
  die $resp->status_line unless $resp->is_success;
  return parse_results( $resp->content );
}

sub parse_results {
  my $src      = shift;
  my @path     = ();                              # tag.class path
  my @buf      = ();
  my %want     = map { $_ => 1 } qw( div pre );
  my $get_path = sub { join '/', @path };

  my $p = HTML::Parser->new(
    start_h => [
      sub {
        push @path, join '.', grep defined, $_[0], $_[1]{class}
         if $want{ $_[0] };
      },
      'tagname,attr'
    ],
    end_h => [ sub { pop @path if $want{ shift() } }, 'tagname' ],
    text_h => [
      sub { push @buf, shift if $get_path->() eq 'div.results/pre' },
      'dtext'
    ]
  );
  $p->parse( $src );
  return trim( join ' ', @buf );
}

sub trim {
  my $s = shift;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  $s =~ s/\s+/ /;
  return $s;
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

