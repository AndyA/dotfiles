#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;

use constant DETAILS => glob
 '~/.cpan/sources/modules/02packages.details.txt.gz';

die "Please name an author\n" unless @ARGV;
my $catalog = read_catalog( DETAILS );
while ( my $id = shift ) {
  if ( my $mods = $catalog->{ uc $id } ) {
    print "$_\n" for sort keys %$mods;
  }
  else {
    warn "No author $id\n";
  }
}

sub dist_name {
  my ( $dist, $info ) = @_;

  if ( $dist =~ m{^([-\w])/(\1[-\w])/(\2[-\w]*)/(.+)$} ) {
    my ( $id, $leaf ) = ( $3, $4 );
    my @mods = sort { length $a <=> length $b } map { $_->[0] } @$info
     or die "No modules for $dist\n";
    my $vpat = qr{v?\d+(?:\.[\d_]+)*};
    if ( $leaf =~ /^(.*?)-$vpat(?:\.\w+)+$/ ) {
      ( my $pkg = $1 ) =~ s/-/::/g;
      return ( $id, $pkg ) if grep { $_ eq $pkg } @mods;
    }
    return ( $id, $mods[0] );
  }
  else {
    warn "$dist is a bit odd\n";
  }
}

sub read_catalog {
  my $details = shift;

  my %catalog = ();

  read_packages(
    $details,
    sub {
      my ( $mod, $ver, $dist ) = @_;
      push @{ $catalog{$dist} }, [ $mod, $ver ];
    }
  );

  my %by_author = ();

  DIST: while ( my ( $dist, $info ) = each %catalog ) {
    my ( $id, $name ) = dist_name( $dist, $info );
    $by_author{$id}{$name} = $dist;
  }

  return \%by_author;
}

sub read_packages {
  my ( $details, $cb ) = @_;
  -e $details or die "$details not found\n";
  open my $dh, '-|', 'gzip', '-cd', $details
   or die "Can't expand $details\n";
  while ( <$dh> ) {
    chomp;
    if ( /^\s*$/ .. 0 ) {
      next if /^\s*$/;
      my ( $mod, $ver, $dist ) = split /\s+/;
      $cb->( $mod, $ver, $dist );
    }
  }
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

