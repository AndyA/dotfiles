#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Find;
use File::Spec;
use PPI;
use PPI::Find;

=head1 NAME

ptags - generate ctags files from Perl source

=head1 USAGE

 ptags [options] <files or modules>

=head1 OPTIONS

 --abs              Emit absolute filenames
 --installed        Scan all installed modules. Slow.
 -Ipath             Add to search path
 --sort             Sort the output
 --depth=N          Follow use and require to depth N
 --progress         Display scanned files on STDERR
 --help, -?         See this text
 --man              See man page

=cut

my $abs           = 0;
my $installed     = 0;
my $only_subs     = 0;
my $only_packages = 0;
my $sort          = 0;
my $max_depth     = 0;
my $progress      = 0;
my $help          = 0;
my $man           = 0;
my @libs          = ();

Getopt::Long::Configure( 'bundling' );
GetOptions(
    'abs'       => \$abs,
    'installed' => \$installed,
    'subs'      => \$only_subs,
    'packages'  => \$only_packages,
    'sort'      => \$sort,
    'depth=i'   => \$max_depth,
    'I=s'       => \@libs,
    'progress'  => \$progress,
    'help|?'    => \$help,
    'man'       => \$man,
) || pod2usage( -verbose => 0 );

pod2usage( -verbose => 1 ) if $help;
pod2usage( -verbose => 2 ) if $man;

die "Please specify only one of --packages, --subs\n"
  if $only_subs && $only_packages;

my $do_subs     = !$only_packages;
my $do_packages = !$only_subs;

my ( $output, $flush ) = make_output_closures( $sort );

my @queue = ();
my %done  = ();

if ( $installed ) {
    # Check all installed modules
    scan_files( grep { $_ ne '.' } @libs, @INC );
}
else {
    pod2usage( -verbose => 0, -msg => 'Please supply some names' )
      unless @ARGV;
    for my $thing ( @ARGV ) {
        scan_thing( $thing );
    }
}

while ( my $spec = shift @queue ) {
    my ( $module, $depth ) = @$spec;
    eval { scan_thing( $module, $depth ) };
    warn $@ if $@;
}

$flush->();

sub make_output_closures {
    my $sort = shift;
    if ( $sort ) {
        my @lines = ();
        return sub { push @lines, join '', @_ },
          sub { print for sort @lines };
    }
    else {
        return sub { print @_ }, sub { };
    }
}

sub scan_files {
    my @dirs = @_;
    find(
        {
            no_chdir => 1,
            wanted   => sub {
                return unless /\.pm$/;
                tags( $File::Find::name );
            },
        },
        @dirs
    );
}

sub package_to_file {
    my $pkg = shift;
    $pkg =~ s{::}{/}g;
    $pkg .= '.pm';
    return $pkg;
}

sub find_on_path {
    my ( $file, @path ) = @_;
    for my $dir ( @path ) {
        my $ffile = File::Spec->catfile( $dir, $file );
        return $ffile if -f $ffile;
    }
    return;
}

sub is_package {
    my $name = shift;
    return $name =~ /^\w+(?:::\w+)*$/;
}

sub scan_thing {
    my $thing = shift;
    my $depth = shift || 0;
    if ( -f $thing ) {
        tags( $thing, $depth );
    }
    elsif ( -d $thing ) {
        scan_files( $thing, $depth );
    }
    elsif ( is_package( $thing ) ) {
        my $pfile = package_to_file( $thing );
        if ( my $ffile
            = find_on_path( $pfile, ( map { glob } @libs ), @INC ) ) {
            tags( $ffile, $depth );
        }
        else {
            die "Can't find $thing ($pfile)\n";
        }
    }
    else {
        die "Can't find $thing\n";
    }
}

# TODO: Support VIM ctags syntax:
#   http://ctags.sourceforge.net/ctags.html

sub tags {
    my $file = shift;
    my $depth = shift || 0;
    return if $done{$file}++;
    print STDERR "$file\n" if $progress;
    my $doc = PPI::Document->new( $file );
    unless ( $doc ) {
        warn "Failed to parse $file\n";
        return;
    }
    $doc->index_locations;
    my $find = PPI::Find->new(
        sub {
            my ( $ele, $top ) = @_;
            if (   $do_packages
                && $ele->isa( 'PPI::Statement::Package' ) ) {
                my $name = $ele->namespace;
                return unless is_package( $name );
                tag( $name, $file, $ele->location );
            }
            elsif ( $do_subs && $ele->isa( 'PPI::Statement::Sub' ) ) {
                my $name = $ele->name;
                return if $name =~ /^[A-Z]+$/;
                # sub names follow the same naming rules as package
                # names.
                return unless is_package( $name );
                tag( $name, $file, $ele->location );
            }
            elsif ($depth < $max_depth
                && $ele->isa( 'PPI::Statement::Include' ) ) {
                my $inc = $ele->module;
                push @queue, [ $inc, $depth + 1 ] if $inc;
            }
            return 0;
        }
    );
    $find->in( $doc );
}

sub tag {
    my ( $name, $file,    $location ) = @_;
    my ( $line, $rowchar, $col )      = @$location;
    $file = File::Spec->rel2abs( $file ) if $abs;
    $output->( "$name\t$file\t$line\n" );
}
