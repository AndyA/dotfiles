#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use XML::LibXML;
use XML::LibXML::XPathContext;

my %Opt = ( depth => undef );

GetOptions( 'depth:i' => \$Opt{depth}, ) or die;

for my $url ( @ARGV ) {
  $url =~ s{/$}{};
  walk_tree(
    $url,
    sub {
      my $dir = shift;
      print "$dir\n";
    }
  );
}

sub walk_tree {
  my ( $url, $cb ) = @_;
  my @q = ( [ $url, 0 ] );
  DIR:
  while ( my $info = shift @q ) {
    my ( $dir, $depth ) = @$info;
    $cb->( $dir );
    next DIR if defined $Opt{depth} && $depth >= $Opt{depth};
    push @q, map { [ $_, $depth + 1 ] } safe_subdirs( $dir );
  }
}

sub safe_subdirs {
  my @s = eval { subdirs( @_ ) };
  return @s unless $@;
  warn $@;
  return;
}

sub subdirs {
  my $url = shift;
  my @cmd = ( 'svn', 'info', '--depth', 'immediates', '--xml', $url );
  open my $ch, '-|', @cmd or die "Command failed: $!\n";
  my $xml = do { local $/; <$ch> };
  close $ch or die "Command failed: exit $?\n";
  return parse_info( $url, $xml );
}

sub parse_info {
  my ( $url, $xml ) = @_;
  my $doc = XML::LibXML->new->parse_string( $xml );
  my $xpc = XML::LibXML::XPathContext->new( $doc );

  my @ents = $xpc->findnodes( q(/info/entry[@kind='dir']/url) );
  return sort grep { $_ ne $url } map { $_->textContent } @ents;
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

