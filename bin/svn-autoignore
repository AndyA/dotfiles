#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use File::Spec;
use Getopt::Long;
use File::Temp;

my %Options = ( wildcard_dot => 0 );

GetOptions( 'w' => \$Options{wildcard_dot} ) or die;

@ARGV = ( '.' ) unless @ARGV;
my $by_dir = get_unversioned( @ARGV );
for my $dir ( keys %$by_dir ) {
  ignore( $dir, @{ $by_dir->{$dir} } );
}

sub ignore {
  my ( $dir, @files ) = @_;

  $dir = '.' if $dir eq '';

  open my $sh, '-|', 'svn', 'propget', 'svn:ignore', $dir
   or die "Can't svn propget svn:ignore $dir: $?\n";
  chomp( my @ignore = <$sh> );
  close $sh or die "Can't svn propget svn:ignore $dir: $?\n";

  my @pat = ();
  my @new = ();
  for my $file ( @ignore, @files ) {
    if ( @pat ) {
      my $exc = join '|', map { "(?:$_)" } @pat;
      next if $file =~ /$exc/;
    }
    if ( $Options{wildcard_dot} && $file =~ m{.+\.([^.]+)$} ) {
      $file = "*.$1";
    }
    push @pat, glob_to_re( $file );
    push @new, $file;
  }
  my $ig = File::Temp->new;
  {
    open my $if, '>', "$ig" or die "Can't write $ig: $!\n";
    print $if "$_\n" for grep length, sort @new;
  }
  system 'svn', 'propset', 'svn:ignore', $dir, '-F', "$ig"
   and die "Can't set svn:ignore on $dir: $?\n";
}

sub glob_to_re {
  my $glob  = shift;
  my $to_re = sub {
    my $atom = shift;
    return '.'  if $atom eq '?';
    return '.*' if $atom eq '*';
    return quotemeta( $atom );
  };
  $glob =~ s/([\*\?]|[^\*\?]+)/$to_re->($1)/eg;
  return "^$glob\$";
}

sub get_unversioned {
  my $dir    = shift;
  my $by_dir = {};
  open my $sh, '-|', 'svn', 'status' or die "Can't svn status: $?\n";
  while ( <$sh> ) {
    chomp;
    my ( $mark, $file ) = split /\s+/;
    next unless $mark eq '?';
    my ( $vol, $dir, $base ) = File::Spec->splitpath( $file );
    push @{ $by_dir->{"$vol$dir"} }, $base;
  }
  close $sh or die "Can't svn status: $?\n";
  return $by_dir;
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

