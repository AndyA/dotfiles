#!/usr/bin/env perl

use strict;
use warnings;

use File::Find;
use Getopt::Long;
use JSON;
use Path::Class;
use XML::LibXML::XPathContext;
use XML::LibXML;

my %O = (
  o   => 'sift',
  key => [
    'size/{video.width}x{video.height}',
    'format/{video.format},{audio.format}',
    'info/{video.format},{audio.format}/{video.width}x{video.height}',
  ],
);

my @failed = ();

GetOptions( 'o:s' => \$O{o} ) or die;

for my $obj (@ARGV) {
  if ( -f $obj ) {
    sift($obj);
    next;
  }

  find {
    wanted => sub {
      if ( -d $_ ) {
        my $term = dir($_)->basename;
        if ( $term eq $O{o} ) {
          $File::Find::prune = 1;
          return;
        }
      }
      return unless -f $_;
      sift($_);
    },
    no_chdir => 1
   },
   $obj;
}

if (@failed) {
  print "Problems:\n";
  for my $fail (@failed) {
    print "  $fail->{file}: $fail->{msg}\n";
  }
}

sub tidy {
  my $str = shift;
  for ($str) { s/^\s+//; s/\s+$// }
  return $str;
}

sub fail {
  my ( $file, $msg ) = @_;
  push @failed, { file => $file, msg => tidy($msg) };
}

sub sift {
  my $file = file shift;
  print "$file\n";
  my $info = eval { mediainfo($file) };
  unless ($info) {
    fail( $file, $@ );
    return;
  }
  my $dir  = $file->parent;
  my $name = $file->basename;
  for my $key ( @{ $O{key} } ) {
    my $path = expand( $info, $key );
    my $ofile = dir $dir, $O{o}, $path, $name;
    next if -f $ofile;
    print "  $ofile\n";
    $ofile->parent->mkpath;
    link $file, $ofile;
  }
}

sub expand {
  my ( $info, $expr ) = @_;
  my $resolve = sub {
    my $v = find_value( $info, shift );
    return defined $v ? $v : 'unknown';
  };
  $expr =~ s/\{([\w.]+)\}/$resolve->($1)/eg;
  return $expr;
}

sub find_value {
  my ( $doc, $key ) = @_;
  my @p   = split /\./, $key;
  my $k   = pop @p;
  my $obj = walk_path( $doc, @p );
  return unless defined $obj;
  return search( $obj, $k );
}

sub search {
  my ( $doc, $key ) = @_;
  die unless ref $doc;

  return $doc->{$key}
   if 'HASH' eq ref $doc
   && exists $doc->{$key}
   && !ref $doc->{$key};

  if ( 'HASH' eq ref $doc ) {
    for my $sdoc ( values %$doc ) {
      next unless ref $sdoc;
      my $vv = search( $sdoc, $key );
      return $vv if defined $vv;
    }
  }
  elsif ( 'ARRAY' eq ref $doc ) {
    for my $sdoc (@$doc) {
      next unless ref $sdoc;
      my $vv = search( $sdoc, $key );
      return $vv if defined $vv;
    }
  }
  else { die }
  return;
}

sub walk_path {
  my ( $doc, @path ) = @_;

  return $doc unless @path;
  return      unless $doc;
  die         unless ref $doc;

  my $key = shift @path;
  return walk_path( $doc->[$key], @path ) if 'ARRAY' eq ref $doc;
  return walk_path( $doc->{$key}, @path ) if 'HASH' eq ref $doc;
  die;
}

sub mediainfo {
  my $obj = shift;
  return mi_extract( mi_raw($obj) );
}

sub mi_extract {
  my $doc = shift;
  my $xpc = XML::LibXML::XPathContext->new;

  my $info = {};

  for my $trk ( $doc->findnodes('/Mediainfo/File/track') ) {
    my $type = $trk->getAttribute('type');
    my $rec  = {};
    for my $nd ( $trk->nonBlankChildNodes() ) {
      my ( $k, $v ) = ( lc $nd->nodeName, $nd->textContent );
      $rec->{$k} = $v
       unless exists $rec->{$k} && badness( $rec->{$k} ) < badness($v);
    }
    push @{ $info->{ lc $type } }, $rec;
  }
  return $info;
}

sub badness {
  my $val = shift;
  return -1 if $val =~ /^-?\d+(?:\.\d+)?$/;
  return length $val;
}

sub mi_raw {
  my $obj = shift;
  my @cmd = ( mediainfo => -f => '--Output=XML', "$obj" );
  open my $fh, '-|', @cmd;
  my $xml = do { local $/; <$fh> };
  close $fh;
  return XML::LibXML->load_xml( string => $xml );
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

