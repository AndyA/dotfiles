#!/usr/bin/env perl

use strict;
use warnings;
use List::Util qw( max );
use Getopt::Long;

my $exclude = 0;
my $compact = 0;

GetOptions(
  'x' => \$exclude,
  'c' => \$compact,
) or die "Bad option\n";

my @dirs = sort numerically @ARGV;
my @wtf = grep !-d, @dirs;
die "These are not directories: ", join( ', ', @wtf ), "\n" if @wtf;
die "Please name some directories\n" unless @dirs;

my %ct;
for my $dir ( @dirs ) {
  opendir my $dh, $dir or die "Can't read $dir ($!)\n";
  $ct{$_}{$dir}++ for grep /^[^.]/, readdir $dh;
  closedir $dh;
}

my @files = sort keys %ct;
my $nw    = length scalar @files;
my $fw    = max( map length, @files );
my $dw    = max( map length, @dirs ) | 1;

my $flag = 'X' . ( ' ' x ( ( $dw - 1 ) / 2 ) );
my $fmt = "\%${nw}s \%${fw}s" . ( ( " | \%${dw}s" ) x @dirs ) . "\n";
$fmt =~ s/ +//g if $compact;
my @rule = ( ( '=' x $nw ), ( '=' x $fw ), ( '=' x $dw ) x @dirs );
printf $fmt, '#', 'File', @dirs;
printf $fmt, @rule;
my $row = 1;
for my $fi ( @files ) {
  my @flags = map { $ct{$fi}{$_} ? $flag : '' } @dirs;
  next if $exclude && !( grep $_ eq '', @flags );
  printf $fmt, $row++, $fi, @flags;
}
printf $fmt, @rule;

sub cmp_parts {
  my ( $a, $b ) = @_;
  my $aa = shift @$a || 0;
  my $bb = shift @$b || 0;
  my $cmp = "$aa$bb" =~ /^\d+$/ ? $aa <=> $bb : $aa cmp $bb;
  return $cmp || cmp_parts( $a, $b );
}

sub numerically {
  cmp_parts( map { [ split /(?<=\d)(?=\D)|(?<=\D)(?=\d)/ ] } $a, $b );
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

