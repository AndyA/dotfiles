#!/usr/bin/env perl

use v5.10;

use autodie;
use strict;
use warnings;

use English;
use Getopt::Long;
use JSON;
use List::Util qw( max );
use Path::Class;

use constant RCFILE  => glob '~/.wsrc';
use constant WSSTACK => 'WSSTACK';

use constant SYNTAX => <<EOT;
Syntax: $0 <command>

Available commands:

  go <ws>     Go to a workspace

EOT

GetOptions() or die SYNTAX;
@ARGV >= 1   or die SYNTAX;

my ( $cmd, @opt ) = @ARGV;

if ( $cmd eq 'go' ) {
  @opt == 1 or die SYNTAX;
  my ($ws)  = @opt;
  my $rc    = get_rc(RCFILE);
  my @stack = get_stack();
  my $env   = {%ENV};
  my $slot = $rc->{$ws} //= {%$env};
  save_rc( RCFILE, $rc );

  local %ENV = ( %$slot, WSSTACK => join( ':', $ws, @stack ) );
  my $shell = ( getpwuid $UID )[8];
  system $shell;
}
elsif ( $cmd eq 'diff' ) {
  @opt == 0 or die SYNTAX;
  my @stack = get_stack();
  die "Not in a workspace\n" unless @stack;
  my $ws   = $stack[0];
  my $rc   = get_rc(RCFILE);
  my $slot = $rc->{$ws} // {};
  diff( 'base', $slot, $ws, \%ENV );
}
else {
  die SYNTAX;
}

sub diff {
  my ( $an, $a, $bn, $b ) = @_;
  my %k = map { $_ => 1 } keys %$a, keys %$b;
  my $nl = max( length $an, length $bn );
  my $kl = max( map { length $_ } keys %k );
  my $fmt = "%-${nl}s: %${kl}s=%s\n";
  for my $k ( sort keys %k ) {
    my $av = $a->{$k} // '';
    my $bv = $b->{$k} // '';
    if ( $av ne $bv ) {
      printf $fmt, $an, $k, $av;
      printf $fmt, $bn, $k, $bv;
    }
  }
}

sub get_stack {
  defined $ENV{WSSTACK} ? split( /:/, $ENV{WSSTACK} ) : ();
}

sub get_rc {
  return load_rc( $_[0] ) if -e $_[0];
  return {};
}

sub load_rc { JSON->new->decode( scalar file( $_[0] )->slurp ) }

sub save_rc {
  my ( $fn, $stash ) = @_;
  my $tmp = "$fn.tmp";
  print { file($tmp)->openw } JSON->new->pretty->canonical->encode($stash);
  rename $tmp, $fn;
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

